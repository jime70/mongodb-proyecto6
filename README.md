Proyecto 6: AplicaciÃ³n Backend con AutenticaciÃ³n
Tabla de Contenidos
1.	Requisitos
2.	IntroducciÃ³n
3.	InstalaciÃ³n
4.	Estructura del Proyecto
5.	ImplementaciÃ³n de Archivos y Componentes
6.	Funcionamiento
________________________________________
Requisitos
â€¢	NodeJS
â€¢	Express
â€¢	Bcryptjs
â€¢	jsonwebtoken
â€¢	Cors
â€¢	dotenv
â€¢	mongoose
â€¢	nodemon
________________________________________
IntroducciÃ³n
â€¢	En este proyecto, se construyÃ³ una aplicaciÃ³n backend donde se verÃ¡n los pasos para hacer crear dos colecciones, una de clientes y una de productos, el cÃ³digo tambiÃ©n incluye procesos de registro y login de clientes, asÃ­ como tambiÃ©n de autenticaciÃ³n y uso de tokens, usando JWT (JSON Web Tokens). AsÃ­ mismo, se usarÃ¡ MongoDB y Mongoose, para el manejo de datos.

â€¢	Se usarÃ¡ OpenAPI y Swagger para documentar tu aplicaciÃ³n, y tu cÃ³digo deberÃ¡ seguir una estructura de carpetas clara con controladores, modelos y rutas. Finalmente, desplegaremos la aplicaciÃ³n a travÃ©s de render.com y MongoDB Atlas.
________________________________________
InstalaciÃ³n
1.	Clonar el repositorio:
git clone https://github.com/usuario/mongodb-proyecto6
2.	Acceder al directorio del proyecto:
cd mongodb-proyecto6
3.	Instalar las dependencias:
npm install

4.	Configurar el archivo .env: Crear un archivo .env con el siguiente contenido:
PORT=3003
MONGODB_URI=mongodb+srv://jimenaespinoza:admin@bootcampudd.1qx3j.mongodb.net/?retryWrites=true&w=majority&appName=BOOTCAMPUDD
SECRET=UCAMP

URL_BD=mongodb://localhost:27017/merchandise_db

5.	Ejecutar la aplicaciÃ³n:
npm start
________________________________________
Estructura del Proyecto
ðŸ“¦ mongodb-proyecto6
â”œâ”€â”€ ðŸ“‚ config
â”‚   â”œâ”€â”€ db.js
â”‚   ðŸ“‚ controllers
â”‚   â”œâ”€â”€ articlesController.js
â”‚   â”œâ”€â”€ clientController.js
â”‚   ðŸ“‚ middleware
â”‚   â”œâ”€â”€authorization.js
â”‚   ðŸ“‚ models
â”‚   â”œâ”€â”€ Articles.js
â”‚   â”œâ”€â”€ Clients.js
â”‚   ðŸ“‚ node_modules
â”‚   ðŸ“‚ routes
â”‚   â”œâ”€â”€ articlesRoutes.jsx
â”‚   â”œâ”€â”€ clientRoutes.jsx
â”œâ”€â”€ ðŸ“œ .env
â”œâ”€â”€ ðŸ“œ .gitignore
â”œâ”€â”€ ðŸ“œ package-lock.json
â”œâ”€â”€ ðŸ“œ package.json
â”œâ”€â”€ ðŸ“œ server.js

________________________________________
ImplementaciÃ³n de Archivos y Componentes
1.1. server.js
El archivo server.js configura un servidor con Node.js y Express. El archivo configura los endpoints que usa para gestionar los artÃ­culos y los clientes mediante diversas rutas, realizando las distintas importaciones necesarias y conectando la base de datos a MongoDB, mediante la funciÃ³n connectDB(), asegurando el acceso a la informaciÃ³n almacenada.
â€¢	Rutas disponibles:
o	/api/articles â†’ GestiÃ³n de artÃ­culos.
o	/api/clients â†’ GestiÃ³n de clientes.
El servidor se ejecuta en el puerto definido en .env o en el 3004 por defecto.
________________________________________
1.2. DefiniciÃ³n de los modelos en carpeta models
En carpeta models, se define la informaciÃ³n que entregaremos tanto para el archivo Article.js como para el archivo Client.js. El cÃ³digo en estos dos archivos, se usarÃ¡ en carpeta controllers y en carpeta routes, para los distintos endpoints. 
En Article.js 
const mongoose = require('mongoose');

const articleSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true
    },
    size: {
        type: String,
        required: true
    },
    Timestamp: {
        type: Date,
        default: Date.now
    }
});

const Article = mongoose.model('Article', articleSchema);

module.exports = Article; 



En Client.js
const mongoose = require("mongoose")

const clientSchema = mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    username: {
        type: String,
        required: true
    },
    email: {
        type: String, 
        required: true
    },
    password:{
        type: String,
        required: true
    }
}, {
    timestamps: true
});
const Client = mongoose.model("clients", clientSchema);

module.exports = Client;

________________________________________
1.3. Carpeta controllers
En la carpeta controllres, se definen las funciones que procesan las solicitudes del cliente y gestionan la interacciÃ³n con la base de datos a travÃ©s de los modelos. Es decir, los controladores actÃºan como intermediarios entre las rutas y la base de datos.
1. articlesController.js
Este archivo maneja todas las operaciones relacionadas con los artÃ­culos en la base de datos. Contiene las siguientes funciones:
â€¢	getArticles: Obtiene todos los artÃ­culos almacenados en la base de datos.
â€¢	getArticlesById: Busca y devuelve un artÃ­culo especÃ­fico segÃºn su ID.
â€¢	createArticle: Crea un nuevo artÃ­culo con los datos proporcionados en la solicitud.
â€¢	updateArticleById: Modifica un artÃ­culo existente usando su ID.
â€¢	deleteArticleById: Elimina un artÃ­culo especÃ­fico segÃºn su ID.

const Article = require('../models/Articles');

exports.getArticles = async (req, res) => { 
    try {
        const articles = await Article.find({});
        return res.json(articles);
    } catch (error) {
        res.status(500).json({ message: 'There was an error fetching the article', error });
    }
}

exports.getArticlesById = async (req, res) => { 
    try {
        const { id } = req.params;
        const article = await Article.findById(id);
        if (!article) {
            return res.status(404).json({ message: 'Article not found' });
        }
        return res.json(article);
    } catch (error) {
        res.status(500).json({ message: 'There was an error fetching the article', error });
    }
}

exports.createArticle = async (req, res) => { 
    const { name, price, size } = req.body;
    try {
        const newArticle = await Article.create({ name, price, size  });
        return res.json(newArticle);
    } catch (error) {
        res.status(500).json({ message: 'Error creating article', error });
    }
}

exports.updateArticleById = async (req, res) => { 
    try {
        const { id } = req.params;
        const { name, price, size } = req.body;
        const updateArticle = await Article.findByIdAndUpdate(id, { name, price, size}, { new: true });
        res.json({updateArticle});
    } catch (error) {
        res.status(500).json({ message: 'There was an error updating the information', error });
    }
};

exports.deleteArticleById = async (req, res) => { 
    try {
        const { id } = req.params;
        const articleDeleted = await Article.findByIdAndDelete(id);
        return res.json({ articleDeleted});
    } catch (error) {
        res.status(500).json({ message: 'There was an error, please try again.', error });
    }
};


Ejemplo de uso: Cuando un usuario solicita GET /api/articles/readall, esta peticiÃ³n se redirige al controlador, que accede a la base de datos y devuelve la lista de artÃ­culos.
________________________________________
2. clientController.js
Este archivo se encarga de la gestiÃ³n de los clientes y la autenticaciÃ³n. Contiene las siguientes funciones:
â€¢	getAllClients: Recupera y devuelve la lista de todos los clientes registrados.
â€¢	deleteClientById: Elimina un cliente en base a su ID.
â€¢	ClientRegistration: Registra un nuevo cliente, encriptando su contraseÃ±a antes de guardarla en la base de datos.
â€¢	clientLogin: Verifica el usuario y contraseÃ±a, y genera un token JWT para autenticaciÃ³n.
â€¢	ClientVerification: Permite verificar si un usuario autenticado es vÃ¡lido mediante su token JWT.
â€¢	updateClientById: Modifica los datos de un cliente especÃ­fico.

const bcryptjs = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Client = require('../models/Client');

exports.getAllClients = async (req, res) => {
    try {
        const users = await Client.find().select('-password');
        res.json({ users });
    } catch (error) {
        res.status(500).json({
            msg: "There was an error fetching the clients",
            error: error.message
        });
    }
};

exports.deleteClientById = async (req, res) => { 
    try {
        const { id } = req.params;
        const clientDeleted = await Client.findByIdAndDelete(id);
        return res.json({ clientDeleted});
    } catch (error) {
        res.status(500).json({ message: 'There was an error deleting the clients, please try again', error });
    }
};

exports.ClientRegistration = async (req, res) => { 
    const { name, username, email, password } = req.body    
    try {
        const salt = await bcryptjs.genSalt(10);
        console.log('salt =>', salt)
        const hashedPassword = await bcryptjs.hash(password, salt)
        const createdClient = await Client.create({
            name,
            username, 
            email, 
            password: hashedPassword
        })
        return res.json(createdClient);
    } catch (error) {
        return res.status(400).json({ msg: 'There was an error creating the data, please check the information provided' });
    }
};

exports.clientLogin = async (req, res) => { 
    const { username, password } = req.body;
    try {
        let foundCient = await Client.findOne({ username });
        if (!foundCient) {
            return res.status(400).json({ message: 'The username does not exist, verify information.' });
        }
        const correctPassword = await bcryptjs.compare(password, foundCient.password); 
        if (!correctPassword){
            return res.status(400).json({ message: 'The username or the password does not exist, please try again.' });
        }
        const payload = { user: {  id: foundCient.id } };
        jwt.sign(
            payload,
            process.env.SECRET,
            {
                expiresIn: 120
            },
            (error, token) => {
                if (error) throw error;
                res.json({ token });
            }
        )
    } catch (error) {
        res.json({
            message: "Something went wrong",
            error
        })
    }
}

exports.ClientVerification = async (req, res) => { 
    try {
        const client = await Client.findById(req.user.id).select('-password');
        res.json(client);
    } catch (error) {
        res.status(500).json({ message: "There was an error verifying client", error });
    }  
}

exports.updateClientById = async (req, res) => { 
    try {
        const { id } = req.params;
        const { name, username, email, password } = req.body;
        const updateArticle = await Article.findByIdAndUpdate(id, { name, username, email, password}, { new: true });
        res.json({updateArticle});
    } catch (error) {
        res.status(500).json({ message: 'There was an error updating the information', error });
    }
};

Ejemplo de uso: Cuando un usuario se registra enviando POST /api/clients/register, los datos llegan a ClientRegistration, donde se cifra la contraseÃ±a y se almacena el usuario en MongoDB.
________________________________________
1.4. Carpeta middleware
Su propÃ³sito principal es manejar la seguridad y la autenticaciÃ³n antes de que las solicitudes lleguen a los controladores.
En este caso, la carpeta contiene el archivo:
authorization.js
Este archivo define un middleware de autenticaciÃ³n, que verifica si una solicitud tiene un token JWT vÃ¡lido antes de permitir el acceso a ciertas rutas protegidas.
CÃ³mo funciona el middleware de autorizaciÃ³n
1.	Intercepta la solicitud y revisa si en los encabezados (headers) existe un campo llamado authorization.
2.	Verifica si el token estÃ¡ presente. Si no hay un token, devuelve un error 401 Unauthorized.
3.	Descompone el token para validar su formato (debe ser Bearer <token> o Token <token>).
4.	Decodifica el token usando la clave secreta (process.env.SECRET).
5.	Si el token es vÃ¡lido, extrae la informaciÃ³n del usuario y la adjunta al objeto req para que los controladores puedan acceder a ella.
6.	Si el token es invÃ¡lido o ha expirado, devuelve un error y no permite el acceso a la ruta.
Ejemplo de uso en las rutas
En el archivo clientRoutes.js, hay una ruta protegida:
js
CopiarEditar
clientRoutes.get('/verify-client', auth, ClientVerification);
AquÃ­, antes de ejecutar ClientVerification, el middleware auth se encarga de comprobar si el cliente tiene un token JWT vÃ¡lido. Si no lo tiene, la solicitud es rechazada con un mensaje de error. 
________________________________________
1.5. Carpeta routes
Esta carpeta maneja las rutas tanto para el archivo articleRoutes.js como para el archivo clientRoutes.js
Las rutas establecidas son distintas, segÃºn lo establecido en carpeta controllers, creando rutas para obtener informaciÃ³n, agregar informaciÃ³n, actualizarla y borrar (CRUD) 
Ejemplo de uso: 
ArticlesRoutes.post('/create', createArticle);  //localhost:3003/api/articles/create

________________________________________
2. DocumentaciÃ³n
2.1. Render
El proyecto se desplegÃ³ en Render, siguiendo el link:
https://mongodb-proyecto6.onrender.com
2.2. Swagger
El proyecto incluye el archivo documentado en:
PROYECTO-6 MONGO.postman_collection.json-OpenApi3Yaml
________________________________________
3.2. Contacto
jimenaespinoza@gmail.com

